import Base: isless, length

# we sometimes want to sort integers and symbols together, with integers coming first
sortsentinel(x::Integer) = (1,x)
sortsentinel(x::Symbol) = (2,x)

OpOrder = (scal,δ,param,ExpVal,Corr,adag,a,fdag,f,σplus,σminus,σ,OpProd,OpSumAnalytic,OpSum)
for (ii,op1) in enumerate(OpOrder)
    for op2 in OpOrder[ii+1:end]
        @eval isless(::$op1,::$op2) = true
        @eval isless(::$op2,::$op1) = false
    end
end
isless(A::scal,B::scal) = (real(A.v),imag(A.v)) < (real(B.v),imag(B.v))

# do not order parameters by whether they are purely real, or conjugated or not
isless(A::param,B::param) = (A.name,sortsentinel.(A.inds)) < (B.name,sortsentinel.(B.inds))
isless(A::σ,B::σ) = (sortsentinel.(A.inds),A.a) < (sortsentinel.(B.inds),B.a)
for op in (δ,a,adag,f,fdag,σminus,σplus)
    @eval isless(A::$op,B::$op) = sortsentinel.(A.inds) < sortsentinel.(B.inds)
end
for op in (ExpVal,Corr,OpSumAnalytic)
    @eval isless(A::$op,B::$op) = A.A < B.A
end

# return -1 if A<B, 0 if A==B, 1 if B<A
function iterlesseq(A,B)::Int
    resa = iterate(A)
    resb = iterate(B)
    while resa !== nothing && resb !== nothing
        vala, statea = resa
        valb, stateb = resb
        vala == valb || return isless(vala,valb) ? -1 : 1
        resa = iterate(A,statea)
        resb = iterate(B,stateb)
    end
    resa === nothing && resb === nothing && return 0
    # the longer iterator is larger
    resa === nothing ? 1 : -1
end

function isless(A::OpProd,B::OpProd)
    # only evaluate each part that we need for each step of the comparison to avoid unnecessary work
    # order operator products first by number of operators (also within expectation values)
    lA,lB = length(A), length(B)
    lA == lB || return lA < lB
    # then by operators
    c1 = iterlesseq(opiter(A,true),opiter(B,true))
    c1 == 0 || return c1 < 0
    # then by expectation values
    c2 = iterlesseq(expiter(A,true),expiter(B,true))
    c2 == 0 || return c2 < 0
    # then by reversed prefactors (to order params, not scalars)
    rpA = reverse(preftuple(A))
    rpB = reverse(preftuple(B))
    rpA == rpB || return rpA < rpB
    # finally without swallowing opsumanalytic to make sure we always have definite ordering
    iterlesseq(proditer(A,false),proditer(B,false)) < 0
end

# prefactors do not count for length calculation
for op in [scal,δ,param]
    @eval length(::$op) = 0
end
for op in [adag,a,fdag,f,σ,σminus,σplus]
    @eval length(::$op) = 1
end
for op in [ExpVal,Corr,OpSumAnalytic]
    @eval length(A::$op) = length(A.A)
end
length(A::OpProd) = length(A.A) + length(A.B)
